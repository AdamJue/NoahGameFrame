# NoahFrame: 功能架构概述

## 1. 整体架构

NoahFrame 是一个 C++ 游戏服务器框架，采用**基于插件的架构**和**分布式服务器模型**进行设计。这种模块化设计促进了关注点分离、可扩展性和可伸缩性，适用于开发复杂的在线游戏。

*   **基于插件：** 核心引擎和特定游戏的功能被组织到插件中。每个插件可以包含多个模块，每个模块封装一组特定的功能。这使得开发人员可以轻松添加、删除或修改功能。
*   **分布式服务器模型：** 该框架旨在支持分布式部署，其中不同类型的服务器（Master、Login、World、Game、Proxy、DB）处理不同的职责。这些服务器相互通信以管理整体游戏状态和玩家体验。

## 2. 插件系统

插件系统是 NoahFrame 设计的核心，主要由 `NFPluginManager` 管理。

*   **结构：**
    *   **插件 (`NFIPlugin`):** 代表相关功能的集合。插件负责注册和管理自己的模块。它们具有生命周期（`Install`、`Uninstall`）并将生命周期事件（`Awake`、`Init`、`Execute`、`Shut`）传播到其模块。
    *   **模块 (`NFIModule`):** 实际的功能单元。每个模块实现特定的逻辑（例如，内核、日志、网络）。模块也遵循由其父插件和 `NFPluginManager` 启动的相同生命周期事件。
*   **加载与管理 (`NFPluginManager`):**
    *   加载插件配置（确定要激活哪些插件）。
    *   动态加载插件库 (DLLs/SOs) 或集成静态链接的插件。
    *   管理所有已加载插件及其模块的中央注册表。
    *   协调所有插件和模块的生命周期，确保它们以正确的顺序初始化、执行和关闭。
*   **生命周期：** `Awake` -> `Init` -> `AfterInit` -> `CheckConfig` -> `ReadyExecute` -> `Execute` (重复调用) -> `BeforeShut` -> `Shut` -> `Finalize`。这确保了所有组件的有序启动、运行和关闭。

## 3. 核心服务

一组基础模块为游戏开发提供基本服务。

*   **内核 (`NFKernelModule`):** 游戏对象管理的核心。
    *   **对象管理：** 创建、销毁和管理由 `NFGUID` 标识的游戏对象（实体）。
    *   **属性与记录：** 游戏对象拥有：
        *   **属性 (`NFIProperty`):** 命名的、带类型的单个数据值（例如，HP、Name、Position）。可以带有标志 (Save, Public, Private, Cache, Upload)。
        *   **记录 (`NFIRecord`):** 附加到对象的表状数据结构（例如，库存、任务列表），具有行和带类型的列。也带有标志。
    *   **事件系统：** 一个健壮的事件系统，用于类级别事件（例如，对象创建/销毁时）和属性/记录更改事件。可以注册回调以响​​应这些事件。
    *   **调度：** 依赖于专用的调度模块 (`NFIScheduleModule`) 进行基于时间的事件和回调。
*   **配置 (`NFClassModule`, `NFElementModule`):** 管理从 XML 文件加载的游戏配置数据。
    *   **`NFClassModule`:** 定义游戏对象的“蓝图”或“类”（例如，“Player”、“Monster”、“Item”）。类定义指定了该类对象将拥有的属性的名称和类型以及记录的结构。支持继承。
    *   **`NFElementModule`:** 加载这些类的特定实例或“元素”（例如，HP=50、Attack=5 的“Goblin”怪物）。这为不同类型的游戏实体提供了具体数据。
    *   **运行时访问：** 此配置数据在运行时通常是只读的，用于初始化对象并定义其基本特性。
*   **日志 (`NFLogModule`):** 提供灵活的日志系统，具有不同的日志级别（Debug、Info、Warning、Error、Fatal），能够记录到各种输出，并提供用于自定义日志处理的钩子。

## 4. 网络

NoahFrame 包含一个全面的网络层，用于处理客户端-服务器和服务器-服务器之间的通信。

*   **支持的协议：**
    *   **TCP:** 可靠、有序通信的主要协议，用于客户端与服务器之间以及不同服务器实例之间的核心游戏消息。
    *   **HTTP:** 支持服务器 (`NFIHttpServer`) 和客户端 (`NFIHttpClient`) 角色，支持基于 Web 的 API、管理界面或与外部 Web 服务的通信。支持 HTTPS。
    *   **WebSockets (WS):** 通过专用模块 (`NFWSModule`) 表明支持，允许持久、低延迟、全双工的通信，通常通过 HTTP 升级启动。这适用于基于浏览器的客户端或实时 Web 应用程序。
    *   **UDP:** 通过专用模块 (`NFUDPModule`) 表明支持，可用于需要快速、不可靠数据包传输的场景（例如，某些类型的实时数据同步）。
*   **消息处理 (核心游戏玩法 - TCP/WS):**
    *   **消息头 (`NFMsgHead`):** 一个 6 字节的头部（2 字节 MsgID，4 字节总长度）被添加到 TCP/WS 消息之前，便于消息分帧和识别。
    *   **Protocol Buffers (Protobuf):** 游戏消息的主体通常使用 Protocol Buffers 进行序列化。`.proto` 文件（例如 `NFDefine.proto`）定义消息结构和枚举（如 `EGameMsgID`）。这提供了高效、版本容错和多语言的数据序列化。
    *   **接收/发送：** `NFINet` 接口（及其实现）管理将数据读入环形缓冲区，根据头部解析消息，并将消息体分派给注册的处理程序。它还提供发送 Protobuf 序列化数据的函数，自动处理头部的添加。
*   **客户端/服务器通信模式：**
    *   **游戏客户端 <-> 代理服务器：** 客户端通常连接到代理服务器。
    *   **代理服务器 <-> 游戏服务器 / 世界服务器：** 代理服务器在客户端和适当的后端服务器之间转发消息。
    *   **服务器间通信：** 各种服务器类型直接相互通信，以进行注册、数据同步和服务请求（例如，登录服务器查询主服务器，游戏服务器查询世界服务器）。

## 5. 数据管理

NoahFrame 管理静态配置数据和动态运行时数据。

*   **静态配置数据 (XML):**
    *   如“核心服务”中所述，`NFClassModule` 和 `NFElementModule` 从 XML 文件加载对象蓝图和特定元素数据。此数据定义了游戏实体和物品的静态特性。
*   **动态运行时数据持久化 (Redis):**
    *   **`NFINoSqlModule`:** 为 NoSQL 数据库交互提供了一个抽象层，主要实现了 Redis (`NFRedisClient`)。它管理连接并提供 Redis 命令的接口。
    *   **玩家数据管理 (`NFPlayerRedisModule` 示例):**
        *   玩家角色数据（标记为“Save”的属性和记录）被持久化到 Redis。
        *   `NFPlayerRedisModule` 处理玩家登录时从 Redis 加载玩家数据（将其反序列化为 `NFMsg::RoleDataPack` Protobuf 消息），并在他们注销或定期保存时将其保存回去。
    *   **数据映射：** 虽然不是完整的 ORM，但持久对象（如玩家）的属性和记录通常被分组（例如，分成像 `RoleDataPack` 这样的 Protobuf 消息），然后存储，通常存储在 Redis 哈希中，对象的 `NFGUID` 作为键的一部分。单个属性可能是哈希中的字段，记录可能会被序列化为一个单独的字段。
    *   其他模块如 `NFAccountRedisModule` 使用 Redis 处理特定的数据集（例如，帐户凭据）。

## 6. 分布式服务器架构

该框架专为具有专用服务器类型的分布式环境而设计：

*   **主服务器 (`NFMasterModule`):**
    *   **目的：** 中央协调器。管理所有活动服务器实例的列表。
    *   **交互：** 所有其他服务器向其注册。登录/世界服务器向其查询可用的服务器列表。
*   **登录服务器 (`NFLoginLogicModule`):**
    *   **目的：** 处理玩家身份验证和世界服务器选择。
    *   **交互：** 客户端（用于登录），主服务器（用于世界列表），数据库服务器（用于通过 `NFAccountRedisModule` 进行帐户验证）。
*   **世界服务器 (`NFWorldNet_ServerModule` 作为核心):**
    *   **目的：** 从高层次管理整体游戏世界状态、服务器间通信，并跟踪玩家位置（玩家在哪台游戏服务器上）。
    *   **交互：** 向主服务器注册。游戏、代理和数据库服务器连接到它。在这些服务器之间以及向特定游戏服务器上的玩家路由消息。
*   **游戏服务器 (`NFGameServerModule`):**
    *   **目的：** 托管实际的游戏逻辑、场景管理、NPC AI 以及游戏世界子集的实时交互。
    *   **交互：** 客户端（通过代理），世界服务器（注册、状态更新、消息路由），数据库服务器（用于持久化玩家/游戏状态，通常通过世界服务器）。
*   **代理服务器 (`NFProxyLogicModule`):**
    *   **目的：** 客户端连接的网关。在客户端和适当的游戏服务器之间路由消息。
    *   **交互：** 客户端（接受连接），世界服务器（用于路由信息），游戏服务器（转发消息）。
*   **数据库服务器 (例如, `NFDBLogicPlugin` 包含 `NFAccountRedisModule`, `NFPlayerRedisModule`):**
    *   **目的：** 主要使用 Redis 管理持久数据存储。
    *   **交互：** 登录服务器（帐户数据），游戏/世界服务器（玩家数据、其他游戏状态）。向主服务器和世界服务器注册。

## 7. 专用游戏开发模块

NoahFrame 提供了几个高级模块来辅助游戏开发：

*   **Actor 模型 (`NFActorModule`):**
    *   **目的：** 实现基于 Actor 的并发模型（类似于 Akka 或 Orleans），用于在没有显式锁管理的情况下并发管理游戏实体或任务的状态和行为。
    *   **功能：** Actor 通过异步消息进行通信。该模块管理 Actor 的生命周期和消息分派，利用线程池。
    *   **集成：** 通过允许将复杂的状态逻辑并行处理，增强了核心，提高了服务器的响应能力和可伸缩性。
*   **蓝图系统 (`NFBluePrintModule`, `NFBPVirtualMachineModule`):**
    *   **目的：** 提供可视化脚本环境，使开发人员和设计人员能够以图形方式创建和管理游戏逻辑。
    *   **功能：** `NFBluePrintModule` 定义了具有各种节点类型（事件、变量、分支、执行器等）及其之间链接的“逻辑块”的结构。`NFBPVirtualMachineModule` 在运行时执行这些逻辑块。
    *   **集成：** 允许快速原型设计和迭代游戏机制、AI 行为和事件处理，这些可以由 C++ 核心（例如 KernelModule）触发并与之交互。
*   **导航 (`NFNavigationModule`):**
    *   **目的：** 使用 Recast & Detour 库提供 3D 寻路和导航功能。
    *   **功能：** 为游戏场景加载导航网格数据，允许查找点之间的路径，定位随机可到达的点，并对导航网格执行射线投射。
    *   **集成：** 由游戏服务器逻辑用于启用 NPC 和玩家角色的移动、AI 驱动的导航以及游戏场景中的空间查询。
*   **Lua 脚本 (`NFLuaScriptModule`):**
    *   **目的：** 允许嵌入 Lua 脚本用于游戏逻辑、事件处理和扩展 C++ 功能。
    *   **功能：** 提供对核心框架模块（内核、网络、配置、日志、Protobuf 处理）的广泛 Lua 绑定。支持将 Lua 函数注册为各种游戏事件和网络消息的回调。启用脚本的热重载。
    *   **集成：** 提供了一种灵活动态的方式来编写和修改游戏逻辑，而无需重新编译核心 C++ 服务器，从而有助于快速开发和定制。

本文档对 NoahFrame 的功能架构进行了高层次的概述，重点介绍了其关键组件及其交互。该框架的模块化、分布式和可扩展特性使其适用于各种在线游戏项目。
